/* autogenerated by Processing revision 1293 on 2024-04-24 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class median_cut extends PApplet {



Palette p;
PaletteWriter pw;

String imageFn = "input_image_4.png";
PImage image;

public void setup() {
  /* size commented out by preprocessor */;

  image = loadImage(imageFn);

  int numberOfColors = 256;
  int bitsPerChannel = 5;
  int tileSize = 8;

  String imageTitle = imageFn.substring(0, imageFn.lastIndexOf('.'));
  String imageFn = generateFileName("images", imageTitle, "image", numberOfColors, bitsPerChannel, ".png");

  String palFn = generateFileName("pallete-png", imageTitle, "palette", numberOfColors, bitsPerChannel, ".png");
  String cPaletteFn = generateFileName("palette-c", imageTitle, "pal", numberOfColors, bitsPerChannel, ".c");

  p = new Palette(image, numberOfColors, bitsPerChannel);
  ArrayList<Color> palette = p.generatePalette();

  TileSet ts = new TileSet(image, numberOfColors, tileSize, bitsPerChannel);
  ts.draw();

  ts.pal.debugPaletteImage(ts.colors, palFn );
  ts.pal.debugImage(imageFn, image, palette);

  pw = new PaletteWriter(cPaletteFn, imageTitle, palette, bitsPerChannel);
  pw.dump();



  Sprite s = new Sprite(192,0,SpriteSize.SIZE_64x64,1);

  s.tiles = ts.getSpriteTiles(s.s,s.tileIndex);

  s.draw();
  
  noLoop();
}

public String generateFileName(String directory, String baseName, String descriptor, int numColors, int bits, String fileExtension) {
  return "output/" + directory + "/" + baseName + "_" + descriptor + "_" + numColors + "_" + bits + fileExtension;
}
class Color {

  public int r;
  public int g;
  public int b;
  public int a;

  public  Color(int c) {
    this.a = (c >> 24) & 0xFF;
    this.r = (c >> 16) & 0xFF;
    this.g = (c >> 8) & 0xFF;
    this.b = c & 0xFF;
  }

  public Color (int r, int g, int b, int a) {
    this.a = a;
    this.r = r;
    this.g = g;
    this.b = b;
  }
  public Color(int r, int g, int b) {
    this(r, g, b, 255);
  }

  public Color (int[] rgb) {
    this(rgb[0], rgb[1], rgb[2], 255);
  }

  public Color subtract(Color c) {
    int r = this.r - c.r;
    int g = this.g - c.g;
    int b = this.b - c.b;
    int a = this.a - c.a;

    return new Color(r, g, b, a);
  }

  public int squaredDistance(Color b) {

    int dr = b.r - this.r;
    int dg = b.g - this.g;
    int db = b.b - this.b;

    return (dr*dr)+(dg*dg)+(db*db);
  }
  public boolean equals(Color other) {
    return this.r == other.r && this.g == other.g && this.b == other.b && this.a == other.a;
  }

  public String toString() {
    return "Color: [R: "+this.r+", G: "+this.g+", B:"+ this.b+", A:"+this.a+"]";
  }
}
class ColorQuantizer {

  private final int bitsPerChannel;

  public ColorQuantizer(int bitsPerChannel) {
    this.bitsPerChannel = bitsPerChannel;
  }

  public int quantizeColor(int r, int g, int b) {
    int rQuant = quantizeComponent(r);
    int gQuant = quantizeComponent(g);
    int bQuant = quantizeComponent(b);

    return (rQuant << (2 * bitsPerChannel)) | (gQuant << bitsPerChannel) | bQuant;
  }

  public Color deQuantizeColor(int quantizedColor) {
    int r = dequantizeComponent((quantizedColor >> (2 * bitsPerChannel)) & ((1 << bitsPerChannel) - 1));
    int g = dequantizeComponent((quantizedColor >> bitsPerChannel) & ((1 << bitsPerChannel) - 1));
    int b = dequantizeComponent(quantizedColor & ((1 << bitsPerChannel) - 1));

    return new Color(r,g,b);//int[]{r, g, b};
  }
  private int quantizeComponent(int c) {
    int maxVal = (1 << bitsPerChannel) - 1;
    return Math.round(c * maxVal / 255.0f);
  }

  private int dequantizeComponent(int c) {
    int maxVal = (1 << bitsPerChannel) - 1;
    return Math.round(c * 255.0f / maxVal);
  }
}
class Palette {
  private ArrayList<RGBCube> rgbCubes;
  private ArrayList<Color> palette;

  int[] paletteMap;

  private int numColors;
  private int bitsPerChannel;

  private ColorQuantizer cq;

  public Palette(PImage img, int numColors, int bitsPerChannel) {

    this.rgbCubes = new ArrayList<RGBCube>();
    this.palette = new ArrayList<Color>();
    this.numColors = numColors;
    this.bitsPerChannel = bitsPerChannel;
    this.cq = new ColorQuantizer(this.bitsPerChannel);

    img.loadPixels();

    HashSet<Integer> uniqueColors = new HashSet<>(img.pixels.length);
    for (int p : img.pixels) {
      uniqueColors.add(p);
    }

    RGBCube rgbCube = new RGBCube();

    for (int p : uniqueColors) {
      rgbCube.colors.add(new Color(p));
    }
    rgbCubes.add(rgbCube);
  }

  public Palette(PImage img) {
    this(img, 256, 8);
  }

  public Palette(PImage img, int numColors) {
    this(img, numColors, 8);
  }

  public ArrayList<Color> generatePalette() {
    List<RGBCube> tempCubes = new ArrayList<>();
    while (rgbCubes.size() < this.numColors) {
      for (RGBCube rgbCube : rgbCubes) {
        Color ranges = rgbCube.calculateDimensionRanges();
        int longestRange = rgbCube.findLongestDimension(ranges);
        ArrayList<Color> sortedColors = rgbCube.sortByChannel(longestRange);
        ArrayList<ArrayList> splitColorsList = rgbCube.splitColorList(sortedColors);
        for (ArrayList<Color> cl : splitColorsList) {
          tempCubes.add(new RGBCube(cl));
        }
      }
      rgbCubes.clear();
      rgbCubes.addAll(tempCubes);
      tempCubes.clear();
    }
    for (RGBCube rgbCube : rgbCubes) {
      Color averageColor = rgbCube.averageColor();

      int quantizedColor = cq.quantizeColor(averageColor.r, averageColor.g, averageColor.b);
      Color deQuantizedColor = cq.deQuantizeColor(quantizedColor);

      palette.add(deQuantizedColor);
    }
    return palette;
  }

  // Find the index of a color in the palette
  public int index(Color c) {
    for (int i = 0; i < palette.size(); i++) {
      if (palette.get(i).equals(c)) {
        return i;
      }
    }
    return -1; // Return -1 if color is not found
  }

  public int[][] paletteIndices(PImage quantizedImage) {
    int[][] paletteIndices = new int[quantizedImage.width][quantizedImage.height];

    for (int x = 0; x < quantizedImage.width; x++) {
      for (int y = 0; y < quantizedImage.height; y++) {
        int index = x + y * quantizedImage.width;
        int pixelColor = quantizedImage.pixels[index];
        Color currentColor = new Color((pixelColor >> 16) & 0xFF, (pixelColor >> 8) & 0xFF, pixelColor & 0xFF, (pixelColor >> 24) & 0xFF);
        int paletteIndex = index(currentColor);
        paletteIndices[x][y] = paletteIndex;
      }
    }
    return paletteIndices;
  }



  public PImage quantizeImage(PImage img, ArrayList<Color> palette) {
    img.loadPixels();
    for (int i = 0; i<img.pixels.length; i++) {

      int pixelColor = img.pixels[i];
      Color pColor = new Color(pixelColor);
      Color closestColor = findClosestColor(pColor, palette);
      img.pixels[i] = color(closestColor.r, closestColor.g, closestColor.b);
    }
    img.updatePixels();
    return img;
  }

  public Color findClosestColor(Color c, ArrayList<Color> palette) {
    int minDistance = Integer.MAX_VALUE;
    Color closestColor = new Color (0, 0, 0);

    for (Color palColor : palette) {
      int dist = c.squaredDistance(palColor);
      if (dist < minDistance) {
        minDistance = dist;
        closestColor = palColor;
      }
    }

    return closestColor;
  }

  public void debugImage(String filename, PImage image, ArrayList<Color>palette) {
    image.loadPixels();
    for (int i = 0; i<image.pixels.length; i++) {

      int pixelColor = image.pixels[i];
      Color pColor = new Color(pixelColor);
      Color closestColor = findClosestColor(pColor, palette);
      image.pixels[i] = color(closestColor.r, closestColor.g, closestColor.b);
    }
    image.updatePixels();
    image.save(filename);
  }

  public void debugPaletteImage(ArrayList<Color> palette, String filename) {
    PImage debug = createImage(256, 256, RGB);
    debug.loadPixels();
    int index = 0;
    for (int y = 0; y < 16; y++) {
      for (int x = 0; x < 16; x++) {
        Color c;

        if (index < palette.size()) {
          c = palette.get(index);
        } else {
          c = new Color(0, 0, 0, 255);
        }
        int cc = color(c.r, c.g, c.b, c.a);

        for (int dy = 0; dy < 16; dy++) { // Fill a 16x16 pixel block
          for (int dx = 0; dx < 16; dx++) {
            int px = x * 16 + dx;
            int py = y * 16 + dy;
            debug.pixels[py * 256 + px] = cc;
          }
        }
        index++;
      }
    }

    debug.updatePixels();
    debug.save(filename);
  }
}
class PaletteWriter {

  private PrintWriter w;
  private ArrayList<Color> p;
  private ColorQuantizer cq;

  private int bitsPerChannel;

  String name;

  public PaletteWriter(String fn, String paletteName, ArrayList<Color> palette, int bitsPerChannel) {
    w = createWriter(fn);
    p = palette;
    name = paletteName;

    this.bitsPerChannel = bitsPerChannel;
    this.cq = new ColorQuantizer(this.bitsPerChannel);
  }

  public void dump() {
    // Include statements and array definitions
    w.println("#include \"memory.h\"");
    w.println("unsigned short EWRAM_DATA generated_palette[256];");

    // Start of array
    w.println("const unsigned short "+name+"["+p.size()+"] = {");

    for (int i = 0; i < p.size(); i++) {

      Color c = p.get(i);

      int quantizedColor = cq.quantizeColor(c.b, c.g, c.r); // blue and red are reversed because the GBA likes it that way.

      w.print(String.format("0x%04X", quantizedColor)); // Format as hexadecimal

      // Handle commas and line breaks
      if (i < p.size() - 1) w.print(", ");
      if ((i + 1) % 16 == 0) w.println();
    }

    // End of array
    w.println("};");
    w.flush(); // Make sure to flush the writer to ensure all data is written
    w.close(); // Close the writer to free resources
  }
}




class RGBCube {
  public ArrayList<Color> colors;

  public Color min; // min RGBA
  public Color max; // max RGBA

  private final int RED = 0;
  private final int GREEN = 1;
  private final int BLUE = 2;

  public RGBCube () {
    this.colors = new ArrayList<Color>();

    this.max = new Color(0, 0, 0);
    this.min = new Color(255, 255, 255);
  }

  public RGBCube(ArrayList<Color> colors) {
    this.colors = colors;

    this.max = new Color(0, 0, 0);
    this.min = new Color(255, 255, 255);
  }

  public Color calculateDimensionRanges() {
    for (Color c : colors) {
      if (c.r > max.r) {
        max.r = c.r;
      }
      if (c.r < min.r) {
        min.r = c.r;
      }
      if (c.g > max.g) {
        max.g = c.g;
      }
      if (c.g < min.g) {
        min.g = c.g;
      }
      if (c.b > max.b) {
        max.b = c.b;
      }
      if (c.b < min.b  ) {
        min.b = c.b;
      }
    }

    return max.subtract(min);
  }

  public int findLongestDimension(Color ranges) {
    int maxRange = ranges.r;
    int longestDim = RED;

    if (ranges.g > maxRange) {
      maxRange = ranges.g;
      longestDim = GREEN;
    }
    if (ranges.b > maxRange) {
      maxRange = ranges.b;
      longestDim = BLUE;
    }

    return longestDim;
  }

  public ArrayList<Color> sortByChannel(int channel) {

    ArrayList<Color> sortedColors = new ArrayList<Color>();

    for (Color c : this.colors) {
      sortedColors.add(c);
    }

    Collections.sort(sortedColors, new Comparator<Color>() {
      public int compare(Color c1, Color c2) {
        switch (channel) {
        case RED:
          return c1.r - c2.r;
        case GREEN:
          return c1.g - c2.g;
        case BLUE:
          return c1.b - c2.b;
        default:
          throw new IllegalArgumentException("Invalid channel: " + channel);
        }
      }
    }
    );
    return sortedColors;
  }

  public ArrayList splitColorList(ArrayList<Color> colors) {
    ArrayList<ArrayList> splitColors = new ArrayList<ArrayList>();

    ArrayList<Color> firstHalf = new ArrayList<Color>();
    ArrayList<Color> secondHalf = new ArrayList<Color>();

    int medianIndex = colors.size() / 2;

    for (int i = 0; i<colors.size(); i++) {
      if (i < medianIndex) {
        firstHalf.add(colors.get(i));
      } else {
        secondHalf.add(colors.get(i));
      }
    }

    splitColors.add(firstHalf);
    splitColors.add(secondHalf);

    return splitColors;
  }

  public Color averageColor() {

    int sumRed = 0, sumGreen = 0, sumBlue = 0;
    for (Color c : this.colors) {
      sumRed += c.r;
      sumGreen += c.g;
      sumBlue += c.b;
    }

    int count = this.colors.size();
    int ar = sumRed / count;
    int ag = sumGreen / count;
    int ab = sumBlue / count;

    return new Color(ar, ag, ab);
  }
}
class Sprite {
  private int attribute0;
  private int attribute1;
  private int attribute2;
  private int attribute3;

  // attribute 0 fields
  int shape; // 0: 8 , 1: 16 , 2: 32, 3: 64.
  int colorMode; // 0: 16 colors, 1:256 colors
  int mosaic;
  int effect; // 2 bits, alpha and mask
  int affine; // 2 bits
  int y; // 8 bits (max 255?)

  // attribute 1 fields
  int size; // 0: 8 , 1: 16 , 2: 32, 3: 64.
  int vFlip; // 1 bit
  int hFlip; // 1 bit
  int x; // 9 bits

  // attribute 2 fields
  int paletteBank;
  int priority;
  int tileIndex;

  SpriteSize s;

  Tile tiles;

  int width;
  int height;

  int rows;
  int columns;

  int tileSize = 8;

  public Sprite(int x, int y, SpriteSize size, int tileIndex) {
    this.x = x;
    this.y = y;
    this.s = size;

    this.tileIndex = tileIndex;

    this.width = this.s,getWidth();
    this.height = this.s.getHeight();

    this.columns = s.convertSize(this.width);
    this.rows = s.convertSize(this.height);

    println("w: "+size.getWidth()+" h:"+size.getHeight());
  }

  public void draw() {
        // Calculate the x and y position on the screen to draw the tile
    for(int i = 0; i<tiles.size(); i++) {
      Tile t = tiles.get(i);

      int dx = x + (i % this.columns) * tileSize;
      int dy = y + (i / this.rows) * tileSize;

      image(dx,dy,t.rgba);

    }

  }

  public int getAttribute(int attribute) {

    return attribute;
  }
}

enum SpriteSize {

    SIZE_8x8(8, 8), SIZE_8x16(8, 16), SIZE_8x32(8, 32), SIZE_8x64(8, 64),
    SIZE_16x8(16, 8), SIZE_16x16(16, 16), SIZE_16x32(16, 32), SIZE_16x64(16, 64),
    SIZE_32x8(32, 8), SIZE_32x16(32, 16), SIZE_32x32(32, 32), SIZE_32x64(32, 64),
    SIZE_64x8(64, 8), SIZE_64x16(64, 16), SIZE_64x32(64, 32), SIZE_64x64(64, 64);

  private final int width;
  private final int height;

  SpriteSize(int width, int height) {
    this.width = width;
    this.height = height;
  }

  public int getWidth() {
    return width;
  }

  public int getHeight() {
    return height;
  }
  public int convertSize(int n) {
  return (int) (Math.log(n) / Math.log(2)) - 3;
}
}
class Tile {
  int id;

  public PImage rgba;
  public int[][] paletteIndices;

  public int x;
  public int y;
  public int width;
  public int height;

  private int numColors;
  private int bitsPerChannel;

  
  public Tile () {
  
  }

  public Tile (PImage img) {
    this.rgba = img;
  }
  
  public void draw() {
    image(rgba,this.x,this.y);
  }
}
class TileMap {
  
  public ArrayList<Tile> tiles;
  private int width;
  private int height;
  private int tileSize;
  
  
  public TileMap (int width, int height, int tileSize) {
    this.tiles = new ArrayList<Tile>();
    this.width = width;
    this.height = height;
    this.tileSize = tileSize;
  }
}
class TileSet {
  TileMap tm;
  Palette pal;
  ArrayList<Color> colors;

  PImage sourceImage;
  PImage quantizedImage;
  ArrayList<Tile> tiles;

  int tileColors;
  int tileSize;
  int bitsPerColor;

  int width;
  int height;

  int columns;
  int rows;

  public TileSet(PImage img, int tileColors, int tileSize, int bpc) {
    this.sourceImage = img;
    this.tileColors = tileColors;
    this.tileSize = tileSize;
    this.bitsPerColor = bpc;

    this.width = img.width;
    this.height = img.height;

    this.columns = this.width / tileSize;
    this.rows = this.height / tileSize;

    // create a new palette based on the input image and the number of colors.
    pal = new Palette(this.sourceImage, this.tileColors, this.bitsPerColor);
    colors = pal.generatePalette();

    // create a new tilemap
    TileMap tm = new TileMap(sourceImage.width, sourceImage.height, this.tileSize);

    tiles = new ArrayList<Tile>();

    int index = 0;
    for (int y = 0; y < sourceImage.height; y += tileSize) {
      for (int x = 0; x < sourceImage.width; x += tileSize) {
        Tile tile = new Tile();
        tile.id = index;
        tile.x = x;
        tile.y = y;
        tile.width = tileSize;
        tile.height = tileSize;

        tm.tiles.add(tile);

        index++;
      }
    }
    // quantize the input image according to the palette
    quantizedImage = pal.quantizeImage(img, colors);

    // create tiles from the quantized image;
    index = 0;
    for (int y = 0; y < quantizedImage.height; y += tileSize) {
      for (int x = 0; x < quantizedImage.width; x += tileSize) {
        Tile tile = new Tile();

        tile.rgba = quantizedImage.get(x, y, tileSize, tileSize);

        tile.paletteIndices = pal.paletteIndices(tile.rgba);

        tile.id = index;

        tile.x = x;
        tile.y = y;

        tile.width = tile.rgba.width;
        tile.height = tile.rgba.height;

        tiles.add(tile);

        index++;
      }
    }
  }

  public Tiles getSpriteTiles(SpriteSize s, int tileIndex) {
    ArrayList<Tile> spriteTiles = new ArrayList<Tile>;

    int startRow = tileIndex / this.columns; 
    int startCol = tileIndex % this.columns; 

    int tileWidth = s.convertSize(s.width);
    int tileHeight = s.convertSize(s.height);
    

    for (int row = 0; row < tileHeight; row++) {
      for (int col = 0; col < tileWidth; col++) {
        int currentRow = startRow + row;
        int currentCol = startCol + col;

        if (currentCol < numColumns) { // Check if within the bounds of the tileset width
          int tileIndex = currentRow * numColumns + currentCol;
          tile = tiles.get(tileIndex);
          spriteTiles.add(tile);
        }
      }
    }


    return spriteTiles;
  }

  public void draw() {

    int index = 0;
    int i = 0;
    int spacing = 1;
    for (int y = 0; y < this.height; y += tileSize) {
      int j = 0;
      for (int x = 0; x < this.width; x += tileSize) {

        Tile t = this.tiles.get(index);
        image(t.rgba, x+j*spacing, y+i*spacing);
        j++;
        index++;
      }
      i++;
    }
  }
}


  public void settings() { size(384, 384); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "median_cut" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
